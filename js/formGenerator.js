/**
 * formGenerator.js
 * 
 * Command-line interface and Batch Generator for SpaceHarmony.
 * Uses shared logic from js/modules/FormGeneratorCore.js.
 * 
 * @version 2.0.0
 * @date 2025-12-25
 */

import fs from 'fs';
import path, { dirname } from 'path';
import { fileURLToPath } from 'url';
import { createCanvas } from 'canvas';
import * as THREE from 'three';

import { generateForm } from './modules/FormGeneratorCore.js';
import { GeometryUtils } from './modules/GeometryUtils.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);


// --- Export/Batch Functions ---

export async function generateMultipleForms(config) {

    const {
        count = 10,
        minFaces = 0,
        gridSize = 3,
        pointDensity = 3,
        outputDir = 'generated_forms',
        saveJson = true,
        saveObj = true,
        generateThumbnails = true,
        generationOptions = {}
    } = config;

    const absoluteOutputDir = path.join(__dirname, '..', outputDir); // .. because we are in js/
    const thumbnailsDir = path.join(absoluteOutputDir, 'thumbnails');

    if (fs.existsSync(absoluteOutputDir)) {
        fs.rmSync(absoluteOutputDir, { recursive: true, force: true });
    }
    fs.mkdirSync(absoluteOutputDir, { recursive: true });
    if (generateThumbnails) fs.mkdirSync(thumbnailsDir, { recursive: true });

    console.log(`Generating ${count} forms (minFaces >= ${minFaces})...`);

    const savedFiles = [];
    let validCount = 0;

    for (let i = 1; i <= count; i++) {
        // Use Shared Logic
        const form = generateForm(gridSize, pointDensity, { ...generationOptions, id: i });

        if (form.metadata.faceCount >= minFaces) {
            validCount++;
            const baseName = `SH_Form_${i}`;

            if (saveJson) {
                fs.writeFileSync(path.join(absoluteOutputDir, `${baseName}.json`), JSON.stringify(form, null, 2));
            }
            if (saveObj) {
                const objContent = _generateObjContent(form);
                fs.writeFileSync(path.join(absoluteOutputDir, `${baseName}.obj`), objContent);

                if (generateThumbnails) {
                    await _generateThumbnailCanvas(form, path.join(thumbnailsDir, `${baseName}.png`));
                }
            }

            savedFiles.push({ obj: `${baseName}.obj`, json: `${baseName}.json`, png: `${baseName}.png` });
        }
    }

    // Create Index
    fs.writeFileSync(path.join(absoluteOutputDir, 'obj_index.json'), JSON.stringify(savedFiles.map(f => ({
        obj: f.obj,
        json: f.json,
        thumbnail: `thumbnails/${f.png}`
    })), null, 2));

    console.log(`Complete. Generated ${validCount} valid forms.`);
}

function _generateObjContent(form) {
    let out = "# Generated by SpaceHarmony\n";
    form.points.forEach(p => {
        out += `v ${p.x} ${p.y} ${p.z}\n`;
    });
    // OBJ indices are 1-based
    // Need a robust map since points are unique objects
    const pMap = new Map();
    form.points.forEach((p, i) => pMap.set(GeometryUtils.pointKey(p), i + 1));

    form.lines.forEach(l => {
        const i1 = pMap.get(GeometryUtils.pointKey(l.start));
        const i2 = pMap.get(GeometryUtils.pointKey(l.end));
        if (i1 && i2) {
            out += `l ${i1} ${i2}\n`;
        }
    });
    return out;
}

async function _generateThumbnailCanvas(form, thumbPath, width = 400, height = 300) {
    try {
        const canvas = createCanvas(width, height);
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#1e1e1e';
        ctx.fillRect(0, 0, width, height);

        // Simple Isometric Projection
        const deg2rad = (d) => d * Math.PI / 180;
        const Rx = deg2rad(-30);
        const Ry = deg2rad(45);
        const cosX = Math.cos(Rx), sinX = Math.sin(Rx);
        const cosY = Math.cos(Ry), sinY = Math.sin(Ry);

        const project = (p) => {
            let x = p.x, y = p.y, z = p.z;
            let y1 = y * cosX - z * sinX;
            let z1 = y * sinX + z * cosX;
            let x2 = x * cosY + z1 * sinY;
            let z2 = -x * sinY + z1 * cosY;
            return { x: x2, y: y1 };
        };

        const projPoints = form.points.map(project);

        // Bounds calc
        const xs = projPoints.map(p => p.x);
        const ys = projPoints.map(p => p.y);
        const minX = Math.min(...xs), maxX = Math.max(...xs);
        const minY = Math.min(...ys), maxY = Math.max(...ys);

        const padding = 20;
        const scale = Math.min((width - 2 * padding) / (maxX - minX || 1), (height - 2 * padding) / (maxY - minY || 1));
        const offX = padding + (width - 2 * padding - (maxX - minX) * scale) / 2;
        const offY = padding + (height - 2 * padding - (maxY - minY) * scale) / 2;

        const toCanvas = (p) => ({
            x: offX + (p.x - minX) * scale,
            y: height - (offY + (p.y - minY) * scale)
        });

        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        form.lines.forEach(l => {
            const a = toCanvas(project(l.start));
            const b = toCanvas(project(l.end));
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(b.x, b.y);
        });
        ctx.stroke();

        fs.writeFileSync(thumbPath, canvas.toBuffer('image/png'));
        return true;
    } catch (e) {
        console.error("Thumb error", e);
        return false;
    }
}

// --- Run if main ---
const isMainModule = (import.meta.url.startsWith('file://') && process.argv[1] === fileURLToPath(import.meta.url));

if (isMainModule) {
    generateMultipleForms({
        count: 5,
        minFaces: 1,
        generationOptions: { symmetryGroup: 'cubic' }
    });
}