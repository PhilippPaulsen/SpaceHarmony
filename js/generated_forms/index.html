
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpaceHarmony - Form-Galerie</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 0; background-color: #121212; color: #e0e0e0; }
        header { text-align: center; padding: 2rem; border-bottom: 1px solid #333; }
        h1 { margin: 0; font-size: 2rem; font-weight: 300; letter-spacing: 1px; }
        main { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 2rem; padding: 2rem; }
        .scene-wrapper {
            background-color: #1e1e1e; 
            border: 1px solid #333; 
            border-radius: 8px; 
            overflow: hidden; 
            box-shadow: 0 4px 8px rgba(0,0,0,0.2); 
            transition: transform 0.2s ease;
            /* Set a fixed aspect-ratio or min-height for placeholders */
            min-height: 320px; 
            display: flex;
            flex-direction: column;
        }
        .scene-wrapper:hover { transform: translateY(-5px); box-shadow: 0 8px 16px rgba(0,0,0,0.3); }
        h2 { font-size: 0.9rem; font-weight: 400; text-align: center; padding: 0.8rem; margin: 0; background-color: #282828; border-bottom: 1px solid #333; word-wrap: break-word; }
        /* Canvas should fill the available space in the wrapper */
        canvas { display: block; width: 100%; flex-grow: 1; min-height: 0; }
        .empty-state { text-align: center; grid-column: 1 / -1; padding: 4rem; }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <header><h1>SpaceHarmony Form-Galerie</h1></header>
    <main id="gallery-container"></main>

    <script type="module">
        import * as THREE from 'three';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const objFiles = ["SH_PD3_L9_F0_T0_1.obj","SH_PD3_L10_F0_T0_2.obj","SH_PD3_L15_F0_T0_3.obj","SH_PD3_L9_F0_T0_4.obj","SH_PD3_L12_F0_T0_5.obj","SH_PD3_L12_F0_T0_6.obj","SH_PD3_L22_F0_T0_7.obj","SH_PD3_L13_F0_T0_8.obj","SH_PD3_L16_F0_T0_9.obj","SH_PD3_L25_F0_T0_10.obj","SH_PD3_L6_F0_T0_11.obj","SH_PD3_L15_F0_T0_12.obj","SH_PD3_L21_F0_T0_13.obj","SH_PD3_L21_F0_T0_14.obj","SH_PD3_L19_F0_T0_15.obj","SH_PD3_L20_F0_T0_16.obj","SH_PD3_L22_F0_T0_17.obj","SH_PD3_L12_F0_T0_18.obj","SH_PD3_L13_F0_T0_19.obj","SH_PD3_L18_F0_T0_20.obj","SH_PD3_L22_F0_T0_21.obj","SH_PD3_L21_F0_T0_22.obj","SH_PD3_L21_F0_T0_23.obj","SH_PD3_L8_F0_T0_24.obj","SH_PD3_L22_F0_T0_25.obj","SH_PD3_L17_F0_T0_26.obj","SH_PD3_L20_F0_T0_27.obj","SH_PD3_L23_F0_T0_28.obj","SH_PD3_L7_F0_T0_29.obj","SH_PD3_L13_F0_T0_30.obj","SH_PD3_L10_F0_T0_31.obj","SH_PD3_L9_F0_T0_32.obj","SH_PD3_L24_F0_T0_33.obj","SH_PD3_L20_F0_T0_34.obj","SH_PD3_L23_F0_T0_35.obj","SH_PD3_L16_F0_T0_36.obj","SH_PD3_L25_F0_T0_37.obj","SH_PD3_L15_F0_T0_38.obj","SH_PD3_L18_F0_T0_39.obj","SH_PD3_L17_F0_T0_40.obj","SH_PD3_L14_F0_T0_41.obj","SH_PD3_L16_F0_T0_42.obj","SH_PD3_L13_F0_T0_43.obj","SH_PD3_L17_F0_T0_44.obj","SH_PD3_L9_F0_T0_45.obj","SH_PD3_L7_F0_T0_46.obj","SH_PD3_L7_F0_T0_47.obj","SH_PD3_L13_F0_T0_48.obj","SH_PD3_L9_F0_T0_49.obj","SH_PD3_L23_F0_T0_50.obj"];
        const container = document.getElementById('gallery-container');

        // Map to store active Three.js scenes by their DOM element
        const activeScenes = new Map();

        if (objFiles.length === 0) {
            container.innerHTML = '<div class="empty-state"><p>Keine Formen zum Anzeigen gefunden. FÃ¼hre den Generator aus, um neue Formen zu erstellen.</p></div>';
        }

        // --- IntersectionObserver Callback ---
        // This function is called whenever an observed element enters or leaves the viewport.
        const observerCallback = (entries, observer) => {
            entries.forEach(entry => {
                const wrapper = entry.target;
                const objPath = wrapper.dataset.objPath;

                if (entry.isIntersecting) {
                    // Element is visible: If no scene is active for it, create one.
                    if (!activeScenes.has(wrapper)) {
                        const canvas = document.createElement('canvas');
                        wrapper.appendChild(canvas);
                        
                        const sceneContext = initScene(canvas, objPath);
                        activeScenes.set(wrapper, sceneContext);
                    }
                } else {
                    // Element is not visible: If a scene is active, destroy it to free resources.
                    if (activeScenes.has(wrapper)) {
                        destroyScene(activeScenes.get(wrapper));
                        activeScenes.delete(wrapper);
                        wrapper.querySelector('canvas')?.remove();
                    }
                }
            });
        };

        // --- Observer Initialization ---
        const observer = new IntersectionObserver(observerCallback, {
            // The root margin creates a "buffer" area around the viewport.
            // Scenes will be loaded when they are 200px away from being visible
            // and destroyed when they are 200px away after leaving.
            rootMargin: '200px',
        });

        // --- Create Placeholders and Observe ---
        // Instead of creating canvases immediately, we create placeholders.
        objFiles.forEach(fileName => {
            const sceneWrapper = document.createElement('div');
            sceneWrapper.className = 'scene-wrapper';
            // Store the path in a data attribute for the observer to retrieve.
            sceneWrapper.dataset.objPath = fileName;
            
            const title = document.createElement('h2');
            title.textContent = fileName;
            
            sceneWrapper.appendChild(title);
            container.appendChild(sceneWrapper);

            // Start observing the placeholder.
            observer.observe(sceneWrapper);
        });

        // --- Scene Initialization ---
        function initScene(canvas, objPath) {
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1e1e1e);

            const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            const parent = canvas.parentElement;
            const aspect = parent.clientWidth / parent.clientHeight;
            const frustumSize = 5;
            const camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 1000);
            camera.position.set(5, 5, 5);
            camera.lookAt(scene.position);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(8, 10, 5);
            scene.add(dirLight);

            const loader = new OBJLoader();
            loader.load(objPath, 
                (object) => {
                    const box = new THREE.Box3().setFromObject(object);
                    const center = box.getCenter(new THREE.Vector3());
                    object.position.sub(center);

                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = frustumSize / maxDim;
                    object.scale.set(scale, scale, scale);

                    object.traverse(child => {
                        if (child.isMesh) {
                            child.material = new THREE.MeshPhysicalMaterial({
                                color: 0x0077ff, metalness: 0.2, roughness: 0.6,
                                transparent: true, opacity: 0.8, side: THREE.DoubleSide
                            });
                            const wireframe = new THREE.LineSegments(
                                new THREE.WireframeGeometry(child.geometry),
                                new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 1, transparent: true, opacity: 0.5 })
                            );
                            child.add(wireframe);
                        }
                    });
                    scene.add(object);
                },
                undefined, 
                (error) => console.error('Fehler beim Laden von', objPath, error)
            );

            let animationId;
            function animate() {
                animationId = requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();

            const resizeListener = () => {
                const p = canvas.parentElement;
                if (!p) return;
                renderer.setSize(p.clientWidth, p.clientHeight);
                const aspect = p.clientWidth / p.clientHeight;
                camera.left = frustumSize * aspect / -2;
                camera.right = frustumSize * aspect / 2;
                camera.updateProjectionMatrix();
            };
            window.addEventListener('resize', resizeListener);

            return { scene, renderer, controls, animationId, resizeListener };
        }

        // --- Scene Destruction ---
        function destroyScene(context) {
            cancelAnimationFrame(context.animationId);
            window.removeEventListener('resize', context.resizeListener);

            context.scene.traverse(object => {
                if (object.geometry) object.geometry.dispose();
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(material => material.dispose());
                    } else {
                        object.material.dispose();
                    }
                }
            });

            context.controls.dispose();
            context.renderer.dispose();
            context.renderer.forceContextLoss();
        }
    </script>
</body>
</html>
    