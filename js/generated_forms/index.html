
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpaceHarmony - Form-Galerie</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 0; background-color: #121212; color: #e0e0e0; }
        header { text-align: center; padding: 2rem; border-bottom: 1px solid #333; }
        h1 { margin: 0; font-size: 2rem; font-weight: 300; letter-spacing: 1px; }
        main { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 2rem; padding: 2rem; }
        .scene-wrapper {
            position: relative;
            background-color: #1e1e1e; 
            border: 1px solid #333; 
            border-radius: 8px; 
            overflow: hidden; 
            box-shadow: 0 4px 8px rgba(0,0,0,0.2); 
            transition: transform 0.2s ease;
            min-height: 320px; 
            display: flex;
            flex-direction: column;
        }
        .scene-wrapper:hover { transform: translateY(-5px); box-shadow: 0 8px 16px rgba(0,0,0,0.3); }
        h2 { font-size: 0.9rem; font-weight: 400; text-align: center; padding: 0.8rem; margin: 0; background-color: #282828; border-bottom: 1px solid #333; word-wrap: break-word; }
        .visual-container {
            position: relative;
            flex-grow: 1;
        }
        .preview-thumb {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            width: 100%; height: 100%;
            object-fit: cover;
            transition: opacity 0.5s ease-in-out;
            opacity: 1;
            z-index: 2;
        }
        .three-canvas {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            width: 100%; height: 100%;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            z-index: 1;
        }
        .loading-spinner {
            width: 40px; height: 40px;
            border: 4px solid #444;
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 3;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        @keyframes spin { to { transform: translate(-50%, -50%) rotate(360deg); } }
        .empty-state { text-align: center; grid-column: 1 / -1; padding: 4rem; }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <header><h1>SpaceHarmony Form-Galerie</h1></header>
    <main id="gallery-container"></main>

    <script type="module">
        import * as THREE from 'three';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const objFiles = ["SH_PD3_L12_F10_T0_1.obj"];
        const container = document.getElementById('gallery-container');

        const activeScenes = new Map();

        if (objFiles.length === 0) {
            container.innerHTML = '<div class="empty-state"><p>Keine Formen zum Anzeigen gefunden. Führe den Generator aus, um neue Formen zu erstellen.</p></div>';
        }

        const observerCallback = (entries, observer) => {
            entries.forEach(entry => {
                const wrapper = entry.target;
                const visualContainer = wrapper.querySelector('.visual-container');
                if (!visualContainer) return;

                if (entry.isIntersecting) {
                    if (!activeScenes.has(wrapper)) {
                        const spinner = visualContainer.querySelector('.loading-spinner');
                        spinner.style.opacity = '1';

                        const canvas = document.createElement('canvas');
                        canvas.className = 'three-canvas';
                        visualContainer.appendChild(canvas);
                        
                        const onLoaded = () => {
                            const thumb = visualContainer.querySelector('.preview-thumb');
                            if (thumb) thumb.style.opacity = '0';
                            canvas.style.opacity = '1';
                            spinner.style.opacity = '0';
                        };

                        const sceneContext = initScene(canvas, wrapper.dataset.objPath, onLoaded);
                        activeScenes.set(wrapper, sceneContext);
                    }
                } else {
                    if (activeScenes.has(wrapper)) {
                        const thumb = visualContainer.querySelector('.preview-thumb');
                        if (thumb) thumb.style.opacity = '1';

                        destroyScene(activeScenes.get(wrapper));
                        activeScenes.delete(wrapper);
                        visualContainer.querySelector('canvas')?.remove();
                    }
                }
            });
        };

        const observer = new IntersectionObserver(observerCallback, { rootMargin: '200px' });

        objFiles.forEach(fileName => {
            if (!fileName) return;
            const thumbName = fileName.replace('.obj', '.webp');
            const sceneWrapper = document.createElement('div');
            sceneWrapper.className = 'scene-wrapper';
            sceneWrapper.dataset.objPath = fileName;

            const title = document.createElement('h2');
            title.textContent = fileName;
            sceneWrapper.appendChild(title);

            const visualContainer = document.createElement('div');
            visualContainer.className = 'visual-container';

            const spinner = document.createElement('div');
            spinner.className = 'loading-spinner';

            const img = document.createElement('img');
            img.src = 'thumbnails/' + thumbName;
            img.className = 'preview-thumb';
            img.alt = 'Vorschau von ' + fileName;

            visualContainer.appendChild(spinner);
            visualContainer.appendChild(img);

            sceneWrapper.appendChild(visualContainer);
            container.appendChild(sceneWrapper);
            observer.observe(sceneWrapper);
        });

        function initScene(canvas, objPath, onLoadedCallback) {
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1e1e1e);

            const renderer = new THREE.WebGLRenderer({
                context,
                antialias: true,
                preserveDrawingBuffer: true
            });
            renderer.setSize(width, height, false);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Performance-Optimierung für Mobile

            const parent = canvas.parentElement;
            const aspect = parent.clientWidth / parent.clientHeight;
            const frustumSize = 5;
            const camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 1000);
            camera.position.set(5, 5, 5);
            camera.lookAt(scene.position);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(8, 10, 5);
            scene.add(dirLight);

            const loader = new OBJLoader();
            loader.load(objPath, 
                (object) => {
                    const box = new THREE.Box3().setFromObject(object);
                    const center = box.getCenter(new THREE.Vector3());
                    object.position.sub(center);

                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = frustumSize / maxDim;
                    object.scale.set(scale, scale, scale);

                    object.traverse(child => {
                        if (child.isMesh) {
                            child.material = new THREE.MeshPhysicalMaterial({
                                color: 0x0077ff, metalness: 0.2, roughness: 0.6,
                                transparent: true, opacity: 0.8, side: THREE.DoubleSide
                            });
                            const wireframe = new THREE.LineSegments(
                                new THREE.WireframeGeometry(child.geometry),
                                new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 1, transparent: true, opacity: 0.5 })
                            );
                            child.add(wireframe);
                        }
                    });
                    scene.add(object);
                    if(onLoadedCallback) onLoadedCallback(); // Callback nach dem Laden ausführen
                },
                undefined, 
                (error) => console.error('Fehler beim Laden von', objPath, error)
            );

            let animationId;
            function animate() {
                animationId = requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();

            const resizeListener = () => {
                const p = canvas.parentElement;
                if (!p) return;
                renderer.setSize(p.clientWidth, p.clientHeight);
                const aspect = p.clientWidth / p.clientHeight;
                camera.left = frustumSize * aspect / -2;
                camera.right = frustumSize * aspect / 2;
                camera.updateProjectionMatrix();
            };
            window.addEventListener('resize', resizeListener);

            return { scene, renderer, controls, animationId, resizeListener };
        }

        function destroyScene(context) {
            cancelAnimationFrame(context.animationId);
            window.removeEventListener('resize', context.resizeListener);

            context.scene.traverse(object => {
                if (object.geometry) object.geometry.dispose();
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(material => material.dispose());
                    } else {
                        object.material.dispose();
                    }
                }
            });

            context.controls.dispose();
            context.renderer.dispose();
            context.renderer.forceContextLoss();
        }
    </script>
</body>
</html>
    